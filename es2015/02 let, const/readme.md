# ECMAScript 2015

## 02. let, const

..var 키워드는 변수를 선언할 때 사용합니다. 크게 로컬 변수와 글로벌 변수로 구분합니다.  
..로컬 변수는 함수 또는 오브젝트를 스코프로 사용하려는 의도이며, 글로벌 변수는 프로그램 전체에서 공용으로 사용하려는 의도입니다.  
..var 키워드를 사용하지않고 변수를 선언하였으므로 ..글로별 변수입니다.  
..첫 줄에 "use strict" 를 작성하면 .. var 키워드를 작성하지 않아 에러가 발생합니다.  
..함수블록에서 코드를 실행하면, 함수안에 .. 변수가 없으므로 함수 밖으로 나가 검색합니다.

..글로벌 오브젝트에 작성한 변수는 글로벌 오브젝트가 스코프입니다. 글로벌 오브젝트에 작성했으므로 글로벌 변수라고 부르는 것이지, 글로벌 오브젝트에서 보면 로컬 변수입니다.

..let 변수는 호이스팅되지 않습니다.

..변수에 값을 할당하지 않고 선언만 하면 디폴트 값으로 undefined 가 할당됩니다. 자바스크립트에서 undefined 는 값입니다.

..let 변수를 선언하는 가장 큰 목적은 스코프이며 그중에서도 블록 스코프가 돋보입니다. 블록 스코프의 기준은 .. 블록을 나타내는 중괄호 {} 입니다.

..현재 실행중인 스코프의 변수가 Block 에 표시되고 블록 밖 스코프의 변수가 Script 에 표시됩니다.

..논리적으로 접근하면 자바스크립트에 글로벌 오브젝트는 있지만 window 오브젝트는 없습니다.  
..이와같이 window 오브젝트에 글로벌 오브젝트가 존재하는 개념입니다.  
..this 가 window 오브젝트를 참조하는데 window 오브젝트에 let 변수가 없다는 것은 window 오브젝트에 let 변수가 설정되지 않는다는 의미가 됩니다.  

..함수 안에 변수가 없으므로 함수 밖에서 변수를 찾습니다. 이와 같이 let 변수도 가장 가까운 스코프에 있는 변수를 먼저 사용합니다.

..ES5 이지만 strict 모드에서 window.get() 과 같이 get() 앞의 오브젝트 위치에 window 를 작성하면, get() 함수 안에서 this 가 window 오브젝트를 참조합니다.  
..오브젝트를 지정하지 않고 호출하면 window 오브젝트를 참조하지 않습니다.  
.."오브젝트.get()" 형태로 호출해야 하는데, 오브젝트를 작성하지 않았으므로 엔진은 오브젝트 위치에 undefined 를 설정합니다. 따라서 this 가 undefined 를 참조하게 되므로 TypeError 가 발생합니다.

..try-catch 문에서 try 블록 {} 기준으로 블록 스코프를 갖습니다. catch 블록은 스코프를 갖지않으며 try 블록 스코프에 속합니다.

..switch-case 문에서 switch 블록이 블록 스코프입니다. switch 안의 case 는 별도의 스코프를 갖지 않으며 switch 의 스코프에 속합니다.

..자바스크립트는 소스코드를 위에서 아래로 순차적으로 실행합니다. 따라서 호출될 함수를 작성한 후, 아래에서 함수를 호출해야 함수가 호출됩니다. 하지만 함수선언문은 함수를 호출하는 코드를 위에 작성하고 호출될 함수를 아래에 작성해도 함수가 호출됩니다. 이를 호이스팅이라고 합니다.

..var 변수는 함수선언문과 차이가 있습니다. 변수를 사용하는 코드를 위에 작성하고 아래에 변수를 선언해도 에러가 나지 않습니다. 단, 변수값이 undefined 입니다. 함수표현식도 마찬가지입니다.

..반면 let 변수는 호이스팅이 되지 않습니다. 즉, let 변수를 사용하는 코드를 위에 작성하고 아래에 변수를 선언하면 에러가 발생합니다.

..console.log(sports) 아래에 var 변수로 sports 를 선언하고 "스포츠" 를 할당합니다. console.log(sports) 를 실행하면 콘솔에 undefined 가 출력됩니다. 비록 undefined 가 출력되지만 sports 변수를 인식한것으로 호이스팅 된 것입니다. 만약 sports 변수를 참조하지 못했다면 에러가 발생합니다.

..for() 문에서 let 변수는 반복할때마다 스코프를 갖는 반면, var 변수는 스코프를 갖지 않습니다.

..const 변수에 값을 다시 할당하면 에러가 발생합니다.  
..const 변수인 obj 에 값을 할당할 수는 없지만, obj 의 프로젝트에는 값을 할당할 수 있습니다.
